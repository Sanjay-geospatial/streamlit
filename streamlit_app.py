import streamlit as st
import tensorflow as tf
import os
import requests
import gdown
import rioxarray as rxr
from io import BytesIO


MODEL_URL = "https://huggingface.co/SanjayGeospatial/cloud-removal-model/resolve/main/g_model_epoch1.h5"
MODEL_PATH = "g_model_epoch1.h5"

@st.cache_resource
def download_and_load_model():
    if not os.path.exists(MODEL_PATH):
        with st.spinner("Downloading model..."):
            response = requests.get(MODEL_URL)
            if response.status_code == 200:
                with open(MODEL_PATH, "wb") as f:
                    f.write(response.content)
            else:
                st.error("Failed to download model.")
                raise ValueError("Failed to download model.")
    return tf.keras.models.load_model(MODEL_PATH)

model = download_and_load_model()

# Utility: preprocess input image
def preprocess_image(img):
    img = normalized_cloud_free = 2 * (np.array(img) - np.array(img).min()) / (np.array(img).max() - np.array(img).min()) - 1
    img = np.expand_dims(img, axis = 0)
    return img

# Utility: postprocess output image
def postprocess_image(pred):
    pred = ((pred + 1) / 2)**0.4
    return pred

# Streamlit UI
st.title("‚òÅÔ∏è‚Üíüå§Ô∏è Cloud Removal App")
st.write("Upload a cloudy satellite image to see a cloud-free version generated by the model.")

uploaded_file = st.file_uploader("Upload Cloudy Image", type=["jpg", "jpeg", "png", "tif", "tiff"])

if uploaded_file:
    input_image = rxr.open_rasterio(uploaded_file)
    st.image(input_image, caption="Input: Cloudy Image", use_column_width=True)

    with st.spinner("Generating cloud-free image..."):
        input_tensor = preprocess_image(input_image)
        output_tensor = model.predict(input_tensor)
        output_image = postprocess_image(output_tensor)

    st.image(output_image, caption="Output: Cloud-Free Image", use_column_width=True)




